<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
    <title>tcp连接状态分析 </title>
    <meta name="author" content="hongbing" />
    <meta name="renderer" content="webkit">
    <meta name="description" content="hongbing的部落格" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0">
    <link rel="stylesheet" href="/css/default.css" type="text/css" />
    <link rel="stylesheet" href="/css/syntax.css" type="text/css" />
    <link rel="shortcut icon" href="/jinchuan.png" type="image/x-icon" />
    <link rel="alternate" type="application/atom+xml" title="Recent Entries" href="" />
    <script src="/js/jquery-1.7.1.min.js" type="text/javascript"></script>
</head>
<body>
      <div id="header_wrap" class="outer">
        <header class="inner">
                <div id="project_title" align="center"><a href="/">hongbingの部落格</a></div>
                <div id="project_tagline" align="center">ONCE A GEEK, FOREVER A GEEK.</div>
        </header>
</div>
 
         <link rel="stylesheet" href="/js/prettify/prettify.css" />
<style type="text/css">
    body { background:#e8e8e8; }
    @media screen and (max-width: 750px){
        body { background:#fff; }
    }
    @media screen and (max-width: 1020px){
        body { background:#fff; }
    }
</style>

<div id="content">
    <div class="entry">
        <h1 class="entry-title"><a href="/blog/2015/11/05/2015-11-03-tcp-connection-status.html" title="tcp连接状态分析">tcp连接状态分析</a></h1>
        <p class="entry-date">2015-11-05</p>
	<p>在工作中分析排查问题，只要涉及到网络方面，总是感觉无从下手，tcp各种状态的转换，以及每个状态后面各项参数的含义都令人头疼。下面对tcp各状态以及状态转换关系进行详细描述。</p>

<p>首先附上一张学习TCP连接状态必备的神图——TCP状态转换图，后面涉及的所有状态都可以在图中找到相应的<!-- more -->转换模式。</p>

<p><img src="/images/tcp/tcp-status.png" alt="tcp-status" /></p>

<h2 id="tcp">1 tcp握手挥手</h2>
<p>分析tcp的状态，最熟悉的莫过于三次握手，以及四次挥手的各状态变化，在分析之前还是先上一张握手以及挥手的图：<br />
<img src="/images/tcp/3vs4handshake.png" alt="3vs4handshake" /></p>

<h3 id="listen">1.1 LISTEN</h3>
<p>服务器端在准备建立握手协议之前，会打开自己的监听端口，该端口负责与客户端进行通信。服务端调用listen函数就可以进入到LISTEN状态，该状态为等待客户端连接过来时候的状态。listen函数会触发listen系统调用，通知协议进程准备接收socket上的连接请求。<br />
listen系统调用有两个参数，一个是执行socket的描述符fd，另一个是ESTABLISH队列长度的阈值backlog。我们来看看Linux man page是怎样描述backlog的：</p>

<blockquote>
  <p>The behavior of the backlog argument on TCP sockets changed with Linux 2.2. Now it specifies <code>the queue length for completely established sockets waiting to be accepted</code>, instead of the number of incomplete connection requests. The maximum length of the queue for incomplete sockets can be set using /proc/sys/net/ipv4/tcp_max_syn_backlog. When syncookies are enabled there is no logical maximum length and this setting is ignored. See tcp(7) for more information.<br />
If the backlog argument is greater than the value in /proc/sys/net/core/somaxconn, then it is silently truncated to that value; the default value in this file is 128. In kernels before 2.4.25, this limit was a hard coded value, SOMAXCONN, with the value 128.</p>
</blockquote>

<p>Linux man page已经表明，backlog的值为backlog与somaxconn中的较小者。下面的源码清晰的展示了这一关系：</p>

<pre><code class="language-c">// source code based on linux-2.6.32.67
int listen(int fd, int backlog)
{
	struct socket *sock;
	int err, fput_needed;
	int somaxconn;

	sock = sockfd_lookup_light(fd, &amp;err, &amp;fput_needed);
	if (sock) {
		//取得net.core.somaxconn的值
		somaxconn = sock_net(sock-&gt;sk)-&gt;core.sysctl_somaxconn;
		if ((unsigned)backlog &gt; somaxconn)
			backlog = somaxconn;

		err = security_socket_listen(sock, backlog);
		if (!err)
			err = sock-&gt;ops-&gt;listen(sock, backlog);

		fput_light(sock-&gt;file, fput_needed);
	}
	return err;
}
</code></pre>
<p>从源代码中可以看到，ESTABLISH队列长度阈值取的是<code>min(backlog, somaxconn)</code>。</p>

<h3 id="synrecv">1.2 SYN_RECV</h3>
<p>在连接的三次握手中，服务端接收到客户端发来的SYN包，服务端从LISTEN状态转变为SYN_RECV状态。</p>

<p>服务端发送&lt;SYN,ACK&gt;，在客户端收到服务端的&lt;SYN,ACK&gt;包之前，服务端会一直处于SYN_RECV状态，那么SYN_RECV状态会持续多久呢？客户端没有收到服务端发送过来的&lt;SYN,ACK&gt;包，客户端会多久重传SYN包？</p>

<p>对于<strong>客户端</strong>来说：</p>

<blockquote>
  <p>如果客户端在<code>大约6s</code>时间没有接收到服务器的&lt;SYN,ACK&gt;包，那么客户端会因为超时第一次重传SYN包。</p>
</blockquote>

<blockquote>
  <p>接下来，如果仍然没有接收&lt;SYN,ACK&gt;包，那么客户端会在<code>24s后</code>，第二次重传SYN包。</p>
</blockquote>

<blockquote>
  <p>大多数伯克利系统将建立一个新连接的最长时间限制在<code>75s</code>，如果客户端在75s内还没收到服务端发送的&lt;SYN,ACK&gt;包，客户端就放弃此次连接。</p>
</blockquote>

<p>对于<strong>服务端</strong>来说：</p>

<blockquote>
  <p>Linux内核协议栈使用两个队列来管理一个tcp连接，<strong>SYN</strong>（未完成三次握手，半连接，incomplete connection ）队列和<strong>ESTABLISH</strong>（已完成三次握手连接, 全连接， completely established）队列。</p>
</blockquote>

<blockquote>
  <p><img src="/images/tcp/syn_recv.png" alt="syn_recv" /></p>
</blockquote>

<blockquote>
  <p>收到客户端的SYN包后，服务端会发送&lt;SYN,ACK&gt;包，且将接收到syn包的连接请求放到SYN队列中，直到客户端的ACK包到达，或者75s超时。</p>
</blockquote>

<blockquote>
  <p>在服务端发送&lt;SYN,ACK&gt;后，没有收到客户端的ACK，会重传&lt;syn,ack&gt;包直到超时，重传次数由<code>net/ipv4/tcp_synack_retries</code>决定，重传间隔从1s开始，每次翻倍。默认重传5次，那么超时时间为1 + 2 + 4 + 8 + 16 =31s，第5次发出后还要等32s才知道第5次也超时了，所以，总共需要 1s + 2s + 4s+ 8s+ 16s + 32s = 2^6 -1 = 63s，服务端才会断开这个连接。</p>
</blockquote>

<p>服务端每收到一个syn包，就会将请求放到SYN队列中，如果一直没有相应的客户端的ACK的回复，等到队列满时，新来的syn包将会被忽略，这里也是<code>SYN洪泛攻击</code>的地方（攻击者伪造大批的IP地址向服务器发送SYN包请求连接，服务端发送&lt;SYN,ACK&gt;，但是无客户端的回复，直至SYN队列满丢弃正常的连接请求）。</p>

<p>SYN队列的长度由系统<code>net.ipv4.tcp_max_syn_backlog</code>值确定，表示最多允许多大的连接数。</p>

<pre><code class="language-c">// source code based on linux-2.6.32.67
// nr_table_entries的值即为系统调用listen的参数backlog
int reqsk_queue_alloc(struct request_sock_queue *queue, unsigned int nr_table_entries)
{
//......

nr_table_entries = min_t(u32, nr_table_entries, sysctl_max_syn_backlog);
	nr_table_entries = max_t(u32, nr_table_entries, 8);
	nr_table_entries = roundup_pow_of_two(nr_table_entries + 1);

//......

}
</code></pre>
<p>由上面的代码可知，SYN队列的长度系统默认的最小值为8，最大值为<code>min(listen的backlog参数, tcp_max_syn_backlog)</code>,且值设置为2的幂。</p>

<p>ESTABLISH队列表示传输层已经接收到客户端发送的ACK包，但是应用层还没有调用accept来取走连接。ESTABLISHED队列的长度与<code>net.core.somaxconn</code>有关，且其值为<code>min(listen的backlog参数,somaxconn)</code>,前面LISTEN状态的listen系统调用已经明确了这一点。</p>

<p>对于洪泛攻击，可以通过改变linux的tcp参数来减轻压力：</p>

<ul>
  <li>
    <p>改变SYN队列的大小，修改linux系统下<code>net.ipv4.tcp_max_syn_backlog</code>的值。</p>
  </li>
  <li>
    <p>减少重传次数 <code>tcp_synack_retries</code></p>
  </li>
  <li>
    <p>如果处理不过来，直接拒绝连接 <code>tcp_abort_on_overflow</code></p>
  </li>
</ul>

<p>另外如果开启<code>syncookies</code>（忽略<code>net.ipv4.tcp_max_syn_backlog</code>的值），那么可以接收更多的连接请求。当SYN队列满了后，TCP会通过源地址端口、目标地址端口和时间戳打造出一个特别的Sequence Number发回去（又叫cookie），如果是攻击者则不会有响应，如果是正常连接，则会把这个 SYN Cookie发回来，然后服务端可以通过cookie建连接（即使你不在SYN队列中）。</p>

<p>可以使用<code># netstat -antp | grep "SYN_RECV"</code>来检测是否受到SYN洪泛攻击。在系统日志中也可以看到类似<code>possible SYN Flooding attack</code>的警告语句。</p>

<h3 id="closewait">1.3 CLOSE_WAIT</h3>

<p>当服务端接收到客户端的FIN包后，TCP socket变换为CLOSE_WAIT状态。</p>


	<ul class="pager">
            
            <li class="previous"><a href="/blog/2015/11/04/2015-11-02-jetty-deadlock.html" title="jetty6 deadlock">上一篇 jetty6 deadlock</a></li>
	    

            
	</ul>
	<div id="disqus_thread"></div>
<script>
    /**
     *  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
     *  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables
     */
    /*
    var disqus_config = function () {
        this.page.url = PAGE_URL;  // Replace PAGE_URL with your page's canonical URL variable
        this.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
    };
    */
    (function() {  // DON'T EDIT BELOW THIS LINE
        var d = document, s = d.createElement('script');
        
        s.src = '//hongbing.disqus.com/embed.js';
        
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a></noscript>

    </div>

    <div class="sidenav">
	<iframe width="100%" height="85" class="share_self"  frameborder="0" scrolling="no" src="http://widget.weibo.com/weiboshow/index.php?language=&width=0&height=85&fansRow=2&ptype=1&speed=0&skin=1&isTitle=0&noborder=0&isWeibo=0&isFans=0&uid=2702608131&verifier=f3af5509&dpc=1"></iframe>	
    </div>
	
    <div class="sidenav">
        <h2>Blog</h2>
        <ul class="artical-list">
        
            <li><a href="/blog/2015/11/05/2015-11-03-tcp-connection-status.html">tcp连接状态分析</a></li>
        
            <li><a href="/blog/2015/11/04/2015-11-02-jetty-deadlock.html">jetty6 deadlock</a></li>
        
            <li><a href="/blog/2015/11/04/template.html">存在感</a></li>
        
            <li><a href="/blog/2015/08/21/linux-of-blockdump.html">linux系统之block_dump</a></li>
        
            <li><a href="/blog/2015/08/20/linux-of-pdflush.html">linux系统之pdflush</a></li>
        
            <li><a href="/blog/2015/08/11/UnknowHostException.html">UnknowHostException</a></li>
        
            <li><a href="/blog/2015/08/02/haproxy-install.html">haproxy部署</a></li>
        
            <li><a href="/blog/2015/07/25/maven-introduce.html">maven实践</a></li>
        
            <li><a href="/blog/2015/06/21/etcd-vs-consul.html">ETCD vs. Consul</a></li>
        
            <li><a href="/blog/2015/06/21/distributed-id-generator.html">分布式ID生成器</a></li>
        
            <li><a href="/blog/2015/06/17/what-is-good-code.html">什么样的代码才是好的代码</a></li>
        
            <li><a href="/blog/2015/06/17/raft-introduce.html">Raft</a></li>
        
        </ul>
<!--
        <h2>Opinion</h2>
        <ul class="artical-list">
        
        </ul>

        <h2>Project</h2>
        <ul class="artical-list">
        
        </ul>-->
     </div>
</div>
<script src="/js/jquery-1.7.1.min.js"" type="text/javascript"></script>
<script src="/js/post.js" type="text/javascript"></script>

      

</body>
</html>
