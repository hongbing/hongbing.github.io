<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
    <title>linux系统之pdflush </title>
    <meta name="author" content="hongbing" />
    <meta name="renderer" content="webkit">
    <meta name="description" content="hongbing的部落格" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0">
    <link rel="stylesheet" href="/css/default.css" type="text/css" />
    <link rel="stylesheet" href="/css/syntax.css" type="text/css" />
    <link rel="shortcut icon" href="/jinchuan.png" type="image/x-icon" />
    <link rel="alternate" type="application/atom+xml" title="Recent Entries" href="" />
    <script src="/js/jquery-1.7.1.min.js" type="text/javascript"></script>
</head>
<body>
      <div id="header_wrap" class="outer">
        <header class="inner">
                <div id="project_title" align="center"><a href="/">hongbingの部落格</a></div>
                <div id="project_tagline" align="center">ONCE A GEEK, FOREVER A GEEK.</div>
        </header>
</div>
 
         <link rel="stylesheet" href="/js/prettify/prettify.css" />
<style type="text/css">
    body { background:#e8e8e8; }
    @media screen and (max-width: 750px){
        body { background:#fff; }
    }
    @media screen and (max-width: 1020px){
        body { background:#fff; }
    }
</style>

<div id="content">
    <div class="entry">
        <h1 class="entry-title"><a href="/blog/2015/08/20/linux-of-pdflush.html" title="linux系统之pdflush">linux系统之pdflush</a></h1>
        <p class="entry-date">2015-08-20</p>
	<p>当我们向磁盘文件写入数据时，由于内存与磁盘之间数据读取的差异，操作系统不会直接将数据写透（write through）到磁盘上，而是会写到页高速缓存（page cache）中，真正的写磁盘操作会延迟进行，称为写延迟（write delay）。当page cache中的数据比后端存储中的数据还要新时，称page cache中的数据为脏数据（或者脏页，dirty page）。page cache对被缓存的页面范围的定义非常宽泛，任何基于页的对象，包括各种类型<!-- more -->的文件和各种类型的内存映射都可以。如果计算机在运行过程中突然掉电，脏页会来不及写回磁盘，会造成数据丢失。为了尽可能的减少突然掉电带来的数据丢失，同时为了保证系统有足够多的空闲内存空间，操作系统会主动执行将脏页写回磁盘的操作，这也就是pdflush线程的工作。</p>

<p>可以在<code>/proc/meminfo</code>中查看系统page cache的信息。</p>

<pre><code>	MemTotal:        1943676 kB
	MemFree:          165132 kB
	Buffers:           23784 kB
	Cached:           511048 kB
	SwapCached:            0 kB
	......
	SwapTotal:       1989628 kB
	SwapFree:        1989360 kB
	Dirty:                60 kB
	Writeback:             0 kB
	AnonPages:       1009132 kB
	Mapped:           229812 kB
	Shmem:            195912 kB
	Slab:             163756 kB
	......
</code></pre>

<p>Cached即表示当前page cache的大小，Dirty表示脏页的大小。</p>

<p>在linux内核2.6，操作系统维护一组内核线程pdflush执行脏页回写，<code>/proc/sys/vm/nr_pdflush_threads</code>参数可以设置系统中pdflush的线程数。在2.6.32内核版本，pdflush已经被Flusher线程组所取代，Flusher与pdflush的主要区别在于，<strong>pdflush线程与任何任务无关，它们是面向系统所有磁盘的全局任务</strong>，而Flusher线程组可以针对<strong>每个磁盘独立执行回写操作</strong>。下面我们仍然以pdflush来分析。</p>

<p>在下面3种情况下，pdflush线程会被唤醒执行：</p>

<pre><code> 当空闲内存低于一个特定的阈值时;
 当脏页在内存中驻留时间超过一个特定的阈值时;
 当用户调用sync()和fsync()系统调用时。
</code></pre>

<p>第一种情况保证当空闲内存过低时，脏页回写释放内存；第二种情况保证脏页不会无限期的驻留在内存中，最后一种是应用层主动要求执行脏页刷新，可以认为前两种情况是被动式的，是在满足空间（内存空闲空间）和时间（脏页驻留时间）任一条件下进行的。最后一种是主动式的。</p>

<p>首先看看被动式的空间阈值，空间阈值包括两个，一个是<code>/proc/sys/vm/dirty_background_ratio</code>，另一个是<code>/proc/sys/vm/dirty_ratio</code>。</p>

<p>查看Kernel version 2.6.29的doc，看看该doc是怎么描述这两个参数的：</p>

<pre><code>==============================================================
dirty_background_ratio

Contains, as a percentage of total available memory that 
contains free pages and reclaimable pages, the number of pages at 
which the background kernel flusher threads will start writing out
dirty data.

The total avaiable memory is not equal to total system memory.

==============================================================
dirty_ratio

Contains, as a percentage of total available memory that 
contains free pages and reclaimable pages, the number of pages at 
which a process which is generating disk writes will itself 
start writing out dirty data.

The total avaiable memory is not equal to total system memory.

==============================================================
</code></pre>

<p>从doc中可以看出，含义都是表示<code>占可用内存空间的百分比</code>。但是区别在达到<strong>dirty_background_ratio</strong>这个阈值后，pdflush线程会<code>异步</code>执行脏页回写，而当达到<strong>dirty_ratio</strong>阈值时，当时执行写操作的进程会被强制<code>同步</code>执行脏页回写操作，此时所有进程的写操作都会被阻塞,直到脏页占比降低到dirty_ratio之下，如果此时的脏页率仍然在dirty_backgroud_radio之上，将调用pdflush执行异步刷新。</p>

<p>默认的<strong>dirty_ratio</strong>的值应该设置得比<strong>dirty_background_ratio</strong>大。看看工作机中与dirty有关的参数：</p>

<pre><code>$ sysctl -a | grep dirty
vm.dirty_background_bytes = 0
vm.dirty_background_ratio = 5
vm.dirty_bytes = 0
vm.dirty_expire_centisecs = 3000
vm.dirty_ratio = 10
vm.dirty_writeback_centisecs = 500
</code></pre>

<p>这里有一个需要注意的点，占比依据的是<code>可用内存</code>，并不是全部内存。可用内存如何计算？</p>

<blockquote>
  <p>MemFree + Cached - Mapped</p>
</blockquote>

<p>因此，按照前面给出的数字，可用内存为435M，那么当脏页达到21.75M时，就会触发空间阈值。</p>

<p>pdflush唤醒后会调用<code>background_writeout(int)</code>函数，该函数需要传入一个整形值，表示写回的页数。当下面两个条件满足时，pdflush停止回写操作：</p>

<pre><code> 指定的最小数目的脏页数被写回到磁盘；
 空闲内存数已经回升，超过了阈值dirty_background_ratio
</code></pre>

<p>只有达到上面两个条件才会停止回写，除非将所有脏页都写回到磁盘，没有剩余的脏页可以回写了。</p>

<p>再来看看被动式的时间阈值<code>dirty_expire_centisecs</code>（脏页的过期时间），该值在linux doc中是这样描述的：</p>

<pre><code>==============================================================
dirty_expire_centisecs

This tunable is used to define when dirty data is old enough 
to be eligible for writeout by the kernel flusher threads. 

It is expressed in 100 ths of a second.  
Data which has been dirty in-memory for longer than this interval
 will be written out next time a flusher thread wakes up.
==============================================================
</code></pre>

<p><strong>dirty_expire_centisecs</strong>表示脏页在内存中驻留的时间阈值，该值的单位为1/100 秒。另外还有一个参数<code>dirty_writeback_centisecs</code></p>

<pre><code>==============================================================
dirty_writeback_centisecs

The kernel flusher threads will periodically wake up 
and write old data out to disk.  
This tunable expresses the interval between those wakeups,
in 100 ths of a second.

Setting this to zero disables periodic writeback altogether.
==============================================================
</code></pre>

<p>表示系统多久唤醒pdflush来执行回写操作。系统启动时会设置一个定时器，时间为百分之dirty_writeback_centisecs秒，当时间到时，唤醒pdflush线程将驻留时间超过百分之dirty_expire_centisecs秒的脏页回写到磁盘，完成后睡眠，然后重置定时器时间为百分之dirty_writeback_centisecs秒等待下一次唤醒，也即周期性的执行脏页回写操作。</p>

<p>最后来看看主动式的回写操作。当调用fsync()时，会传入一个文件描述符fd，fsync会保证该文件的所有脏页都被刷新到磁盘才返回。</p>

<p>另外还有一种情况，是用户态在调用write函数时，当页面被标记为脏后会检查当前的脏页比率，根据条件刷新脏页。此时的刷新策略与脏页占可用内存比率大于dirty_ratio时一致，同步刷新，阻塞其它的write操作，当比率降到dirty_backgroud_ratio后，wakeup pdflush执行异步刷新。因此用户态调用write()函数也可能引发脏页刷新操作。</p>

<p>参数调优应该根据具体的应用场景来确定，可以将参数值添加到<code>/etc/sysctl.conf</code>文件中，然后执行<code>sysctl -p</code>使其生效。</p>

<p><img src="/images/linuxofpdflush/OMGLookather.jpg" alt="OMGLookather" /></p>

<p><strong>参考</strong>：<br />
[1] <a href="http://www.westnet.com/~gsmith/content/linux-pdflush.htm">http://www.westnet.com/~gsmith/content/linux-pdflush.htm</a><br />
[2] <a href="https://www.kernel.org/doc/">https://www.kernel.org/doc/</a><br />
[3] <a href="http://www.oenhan.com/linux-cache-writeback">http://www.oenhan.com/linux-cache-writeback</a></p>

	<ul class="pager">
            
            <li class="previous"><a href="/blog/2015/08/11/UnknowHostException.html" title="UnknowHostException">上一篇 UnknowHostException</a></li>
	    

            
            <li class="next"><a href="/blog/2015/08/21/linux-of-blockdump.html" title="linux系统之block_dump">下一篇 linux系统之block_dump</a></li>
            
	</ul>
	<div id="disqus_thread"></div>
<script>
    /**
     *  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
     *  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables
     */
    /*
    var disqus_config = function () {
        this.page.url = PAGE_URL;  // Replace PAGE_URL with your page's canonical URL variable
        this.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
    };
    */
    (function() {  // DON'T EDIT BELOW THIS LINE
        var d = document, s = d.createElement('script');
        
        s.src = '//hongbing.disqus.com/embed.js';
        
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a></noscript>

    </div>

    <div class="sidenav">
	<iframe width="100%" height="85" class="share_self"  frameborder="0" scrolling="no" src="http://widget.weibo.com/weiboshow/index.php?language=&width=0&height=85&fansRow=2&ptype=1&speed=0&skin=1&isTitle=0&noborder=0&isWeibo=0&isFans=0&uid=2702608131&verifier=f3af5509&dpc=1"></iframe>	
    </div>
	
    <div class="sidenav">
        <h2>Blog</h2>
        <ul class="artical-list">
        
            <li><a href="/blog/2015/08/21/linux-of-blockdump.html">linux系统之block_dump</a></li>
        
            <li><a href="/blog/2015/08/20/linux-of-pdflush.html">linux系统之pdflush</a></li>
        
            <li><a href="/blog/2015/08/11/UnknowHostException.html">UnknowHostException</a></li>
        
            <li><a href="/blog/2015/08/02/haproxy-install.html">haproxy部署</a></li>
        
            <li><a href="/blog/2015/07/25/maven-introduce.html">maven实践</a></li>
        
            <li><a href="/blog/2015/06/21/etcd-vs-consul.html">ETCD vs. Consul</a></li>
        
            <li><a href="/blog/2015/06/21/distributed-id-generator.html">分布式ID生成器</a></li>
        
            <li><a href="/blog/2015/06/17/what-is-good-code.html">什么样的代码才是好的代码</a></li>
        
            <li><a href="/blog/2015/06/17/raft-introduce.html">Raft</a></li>
        
        </ul>
<!--
        <h2>Opinion</h2>
        <ul class="artical-list">
        
        </ul>

        <h2>Project</h2>
        <ul class="artical-list">
        
        </ul>-->
     </div>
</div>
<script src="/js/jquery-1.7.1.min.js"" type="text/javascript"></script>
<script src="/js/post.js" type="text/javascript"></script>

      

</body>
</html>
