<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
    <title>spring session源码解析 </title>
    <meta name="author" content="hongbing" />
    <meta name="renderer" content="webkit">
    <meta name="description" content="hongbing的部落格" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0">
    <link rel="stylesheet" href="/css/default.css" type="text/css" />
    <link rel="stylesheet" href="/css/syntax.css" type="text/css" />
    <link rel="shortcut icon" href="/jinchuan.png" type="image/x-icon" />
    <link rel="alternate" type="application/atom+xml" title="Recent Entries" href="" />
    <script src="/js/jquery-1.7.1.min.js" type="text/javascript"></script>
</head>
<body>
      <div id="header_wrap" class="outer">
        <header class="inner">
                <div id="project_title" align="center"><a href="/">hongbingの部落格</a></div>
                <div id="project_tagline" align="center">ONCE A GEEK, FOREVER A GEEK</div>
    <!--    
	        <div id="nav" class="navbar">
                         <div id="home" class="navbar"><a href="/">Home</a></div>
                         <div id="archive" class="navbar"><a href="/archive">Archive</a></div>
                         <div id="about" class="navbar"><a href="/about">About</a></div>
                </div>
-->	</header>
</div>
 
         <link rel="stylesheet" href="/js/prettify/prettify.css" />
<style type="text/css">
    body { background:#e8e8e8; }
    @media screen and (max-width: 750px){
        body { background:#fff; }
    }
    @media screen and (max-width: 1020px){
        body { background:#fff; }
    }
</style>

<div id="content">
    <div class="entry">
        <h1 class="entry-title"><a href="/posts/blog/17/02/12/spring-session.html" title="spring session源码解析">spring session源码解析</a></h1>
        <p class="entry-date">2017-02-12</p>
<!--
	
-->
	<p>最近要在项目中做用户踢线的功能，由于项目使用spring session来管理用户session，因此特地翻了翻spring session的源码，看看spring session是如何管理的。我们使用redis来存储session，因此本文只对session在redis中的存储结构以及管理做解析。</p>

<h2 id="1-spring-session使用">1 spring session使用</h2>

<p>Spring Session对HTTP的支持是通过标准的servlet filter来实现的，这个filter必须要配置为拦截所有的web应用请求，并且它最好是filter链中的第一个filter。Spring Session filter会确保随后调用javax.servlet.http.HttpServletRequest的getSession()方法时，都会返回Spring Session的HttpSession实例，而不是应用服务器默认的HttpSession。</p>

<!-- more -->

<p>spring session通过注解<code class="highlighter-rouge">@EnableRedisHttpSession</code>或者xml配置</p>

<div class="highlighter-rouge"><pre class="highlight"><code>&lt;bean class="org.springframework.session.data.redis.config.annotation.web.http.RedisHttpSessionConfiguration"/&gt;
</code></pre>
</div>

<p>来设置spring session的一些参数，比如session的最大活跃时间（maxInactiveIntervalInSeconds），redis命名空间（redisNamespace），session写入到redis的时机（FlushMode）以及如何序列化写到redis中的session value等等。</p>

<p>要想使用spring session，还需要创建名为springSessionRepositoryFilter的<code class="highlighter-rouge">SessionRepositoryFilter</code>类。该类实现了Sevlet Filter接口，当请求穿越sevlet filter链时应该首先经过springSessionRepositoryFilter，这样在后面获取session的时候，得到的将是spring session。为了springSessonRepositoryFilter作为filter链中的第一个，spring session提供了<code class="highlighter-rouge">AbstractHttpSessionApplicationInitializer</code>类， 它实现了<code class="highlighter-rouge">WebApplicationInitializer</code>类，在onStartup方法中将springSessionRepositoryFilter加入到其他fitler链前面。</p>

<div class="highlighter-rouge"><pre class="highlight"><code>public abstract class AbstractHttpSessionApplicationInitializer
		implements WebApplicationInitializer {

	/**
	 * The default name for Spring Session's repository filter.
	 */
	public static final String DEFAULT_FILTER_NAME = "springSessionRepositoryFilter";
  	public void onStartup(ServletContext servletContext) throws ServletException {

			......

		insertSessionRepositoryFilter(servletContext);
		afterSessionRepositoryFilter(servletContext);
	}

	/**
	 * Registers the springSessionRepositoryFilter.
	 * @param servletContext the {@link ServletContext}
	 */
	private void insertSessionRepositoryFilter(ServletContext servletContext) {
		String filterName = DEFAULT_FILTER_NAME;
		DelegatingFilterProxy springSessionRepositoryFilter = new DelegatingFilterProxy(
				filterName);
		String contextAttribute = getWebApplicationContextAttribute();
		if (contextAttribute != null) {
			springSessionRepositoryFilter.setContextAttribute(contextAttribute);
		}
		registerFilter(servletContext, true, filterName, springSessionRepositoryFilter);
	}
}
</code></pre>
</div>

<p>或者也可以在web.xml里面将springSessionRepositoryFilter加入到filter配置的第一个。</p>

<h2 id="2-创建spring-session">2 创建spring session</h2>

<p>RedisSession在创建时设置3个变量creationTime，maxInactiveInterval，lastAccessedTime。maxInactiveInterval默认值为1800，表示1800s之内该session没有被再次使用，则表明该session已过期。每次session被访问都会更新lastAccessedTime的值，session的过期计算公式：<code class="highlighter-rouge">当前时间-lastAccessedTime &gt; maxInactiveInterval</code>.</p>

<div class="highlighter-rouge"><pre class="highlight"><code>/**
* Creates a new instance ensuring to mark all of the new attributes to be
* persisted in the next save operation.
**/
RedisSession() {
	this(new MapSession());
	this.delta.put(CREATION_TIME_ATTR, getCreationTime());
	this.delta.put(MAX_INACTIVE_ATTR, getMaxInactiveIntervalInSeconds());
	this.delta.put(LAST_ACCESSED_ATTR, getLastAccessedTime());
	this.isNew = true;
	this.flushImmediateIfNecessary();
}

public MapSession() {
	this(UUID.randomUUID().toString());
}
</code></pre>
</div>

<p>flushImmediateIfNecessary判断session是否需要立即写入后端存储。</p>

<h2 id="3-获取session">3 获取session</h2>

<p>spring session在redis里面保存的数据包括：</p>

<ul>
  <li>
    <p>SET类型的<code class="highlighter-rouge">spring:session:expireations:[min]</code></p>

    <p>min表示从1970年1月1日0点0分经过的分钟数，SET集合的member为expires:[sessionId],表示members会在在min分钟过期。</p>
  </li>
  <li>
    <p>String类型的<code class="highlighter-rouge">spring:session:sessions:expires:[sessionId]</code></p>

    <p>该数据的TTL表示sessionId过期的剩余时间，即maxInactiveInterval。</p>
  </li>
  <li>
    <p>Hash类型的<code class="highlighter-rouge">spring:session:sessions:[sessionId]</code></p>

    <p>session保存的数据，记录了creationTime，maxInactiveInterval，lastAccessedTime，attribute。前两个数据是用于session过期管理的辅助数据结构。</p>
  </li>
</ul>

<p>应用通过getSession(boolean create)方法来获取session数据，参数create表示session不存在时是否创建新的session。getSession方法首先从请求的“.CURRENT_SESSION”属性来获取currentSession，没有currentSession，则从request取出sessionId，然后读取spring:session:sessions:[sessionId]的值，同时根据lastAccessedTime和MaxInactiveIntervalInSeconds来判断这个session是否过期。如果request中没有sessionId，说明该用户是第一次访问，会根据不同的实现，如RedisSession，MongoExpiringSession，GemFireSession等来创建一个新的session。</p>

<p>另， 从request取sessionId依赖具体的HttpSessionStrategy的实现，spring session给了两个默认的实现CookieHttpSessionStrategy和HeaderHttpSessionStrategy，即从cookie和header中取出sessionId。</p>

<div class="highlighter-rouge"><pre class="highlight"><code>@Override
public HttpSessionWrapper getSession(boolean create) {
	HttpSessionWrapper currentSession = getCurrentSession();
	if (currentSession != null) {
		return currentSession;
	}
	// 从request请求中得到sessionId
	String requestedSessionId = getRequestedSessionId();
	if (requestedSessionId != null
			&amp;&amp; getAttribute(INVALID_SESSION_ID_ATTR) == null) {
		S session = getSession(requestedSessionId);
		if (session != null) {
			this.requestedSessionIdValid = true;
			currentSession = new HttpSessionWrapper(session, getServletContext());
			currentSession.setNew(false);
			setCurrentSession(currentSession);
			return currentSession;
		}
		else {
			// This is an invalid session id. No need to ask again if
			// request.getSession is invoked for the duration of this request
			setAttribute(INVALID_SESSION_ID_ATTR, "true");
		}
	}
	if (!create) {
		return null;
	}

	S session = SessionRepositoryFilter.this.sessionRepository.createSession();
	session.setLastAccessedTime(System.currentTimeMillis());
	currentSession = new HttpSessionWrapper(session, getServletContext());
	setCurrentSession(currentSession);
	return currentSession;
}
</code></pre>
</div>

<p>spring session为什么会使用3个key，而不是一个key？接下来回答。</p>

<h2 id="4-session有效期与删除">4 session有效期与删除</h2>

<p>spring session的有效期指的是访问有效期，每一次访问都会更新lastAccessedTime的值，过期时间为lastAccessedTime + maxInactiveInterval，也即在有效期内每访问一次，有效期就向后延长maxInactiveInterval。</p>

<p>对于过期数据，一般有三种删除策略：</p>

<p>1）<strong>定时删除</strong>，即在设置键的过期时间的同时，创建一个定时器， 当键的过期时间到来时，立即删除。</p>

<p>2）<strong>惰性删除</strong>，即在访问键的时候，判断键是否过期，过期则删除，否则返回该键值。</p>

<p>3）<strong>定期删除</strong>，即每隔一段时间，程序就对数据库进行一次检查，删除里面的过期键。至于要删除多少过期键，以及要检查多少个数据库，则由算法决定。</p>

<p>redis删除过期数据采用的是<code class="highlighter-rouge">懒性删除+定期删除</code>组合策略，也就是数据过期了并不会及时被删除。为了实现session过期的及时性，spring session采用了定时删除的策略，但它并不是如上描述在设置键的同时设置定时器，而是采用固定频率（1分钟）轮询删除过期值，这里的删除是惰性删除。</p>

<p>轮询操作并没有去扫描所有的spring:session:sessions:[sessionId]的过期时间，而是在当前分钟数检查前一分钟应该过期的数据，即spring:session:expirations:[min]的members，然后delete掉spring:session:expirations:[min]，惰性删除spring:session:sessions:expires:[sessionId]。</p>

<p>还有一点是，查看三个数据结构的TTL时间，spring:session:sessions:[sessionId]和spring:session:expirations:[min]比真正的有效期大5分钟，目的是确保当expire key数据过期后，监听事件还能获取到session保存的原始数据。</p>

<div class="highlighter-rouge"><pre class="highlight"><code>@Scheduled(cron = "${spring.session.cleanup.cron.expression:0 * * * * *}")
public void cleanupExpiredSessions() {
	this.expirationPolicy.cleanExpiredSessions();
}

public void cleanExpiredSessions() {
	long now = System.currentTimeMillis();
	long prevMin = roundDownMinute(now);

	// preMin时间到，将spring:session:expirations:[min], set集合中members包括了这一分钟之内需要过期的所有
	// expire key删掉, member元素为expires:[sessionId]
	String expirationKey = getExpirationKey(prevMin);
	Set&lt;Object&gt; sessionsToExpire = this.redis.boundSetOps(expirationKey).members();
	this.redis.delete(expirationKey);
	for (Object session : sessionsToExpire) {
		// sessionKey为spring:session:sessions:expires:[sessionId]
		String sessionKey = getSessionKey((String) session);
		//利用redis的惰性删除策略
		touch(sessionKey);
	}
}
</code></pre>
</div>

<p>spring session在redis中保存了三个key，为什么？
sessions key记录session本身的数据，expires key标记session的准确过期时间，expiration key保证session能够被及时删除，spring监听事件能够被及时处理。</p>

<p>上面的代码展示了session expires key如何被删除，那session每次都是怎样更新过期时间的呢？
每一次http请求，在经过所有的filter处理过后，spring session都会通过onExpirationUpdated()方法来更新session的过期时间， 具体的操作看下面源码的注释。</p>

<div class="highlighter-rouge"><pre class="highlight"><code>public void onExpirationUpdated(Long originalExpirationTimeInMilli,
			ExpiringSession session) {
	String keyToExpire = "expires:" + session.getId();
	long toExpire = roundUpToNextMinute(expiresInMillis(session));

	if (originalExpirationTimeInMilli != null) {
		long originalRoundedUp = roundUpToNextMinute(originalExpirationTimeInMilli);
		// 更新expirations:[min],两个分钟数之内都有这个session，将前一个set中的成员删除
		if (toExpire != originalRoundedUp) {
			String expireKey = getExpirationKey(originalRoundedUp);
			this.redis.boundSetOps(expireKey).remove(keyToExpire);
		}
	}

	long sessionExpireInSeconds = session.getMaxInactiveIntervalInSeconds();
	String sessionKey = getSessionKey(keyToExpire);

	if (sessionExpireInSeconds &lt; 0) {
		this.redis.boundValueOps(sessionKey).append("");
		this.redis.boundValueOps(sessionKey).persist();
		this.redis.boundHashOps(getSessionKey(session.getId())).persist();
		return;
	}

	String expireKey = getExpirationKey(toExpire);
	BoundSetOperations&lt;Object, Object&gt; expireOperations = this.redis
			.boundSetOps(expireKey);
	expireOperations.add(keyToExpire);

	long fiveMinutesAfterExpires = sessionExpireInSeconds
			+ TimeUnit.MINUTES.toSeconds(5);

	// expirations:[min] key的过期时间加5分钟
	expireOperations.expire(fiveMinutesAfterExpires, TimeUnit.SECONDS);
	if (sessionExpireInSeconds == 0) {
		this.redis.delete(sessionKey);
	}
	else {
		// expires:[sessionId] 值为“”，过期时间为MaxInactiveIntervalInSeconds
		this.redis.boundValueOps(sessionKey).append("");
		this.redis.boundValueOps(sessionKey).expire(sessionExpireInSeconds,
				TimeUnit.SECONDS);
	}
	// sessions:[sessionId]的过期时间 加5分钟
	this.redis.boundHashOps(getSessionKey(session.getId()))
			.expire(fiveMinutesAfterExpires, TimeUnit.SECONDS);
}
</code></pre>
</div>

<h2 id="5-参考">5 参考</h2>

<p>[1] <a href="http://docs.spring.io/spring-session/docs/current/reference/html5/">spring-session官网</a></p>

<p>[2] <a href="http://www.infoq.com/cn/articles/Next-Generation-Session-Management-with-Spring-Session">通过Spring Session实现新一代的Session管理</a></p>

<p>[3] <a href="https://segmentfault.com/a/1190000004369392">SpringSession原理解析</a></p>

<p>[4] <a href="https://github.com/spring-projects/spring-session">spring-session github</a></p>

	<ul class="pager">
            
            <li class="previous"><a href="/posts/blog/16/05/21/linux-common-command.html" title="工作中常用的linux命令">上一篇 工作中常用的linux命令</a></li>
	    

            
            <li class="next"><a href="/posts/blog/17/04/22/spring-session-with-sharded-session.html" title="spring-session支持分片redis">下一篇 spring-session支持分片redis</a></li>
            
	</ul>
	<div id="disqus_thread"></div>
<script>
    /**
     *  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
     *  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables
     */
    /*
    var disqus_config = function () {
        this.page.url = PAGE_URL;  // Replace PAGE_URL with your page's canonical URL variable
        this.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
    };
    */
    (function() {  // DON'T EDIT BELOW THIS LINE
        var d = document, s = d.createElement('script');
        
        s.src = '//hongbing.disqus.com/embed.js';
        
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a></noscript>

    </div>

    <div class="sidenav">
	<iframe width="100%" height="85" class="share_self"  frameborder="0" scrolling="no" src="http://widget.weibo.com/weiboshow/index.php?language=&width=0&height=85&fansRow=2&ptype=1&speed=0&skin=1&isTitle=0&noborder=0&isWeibo=0&isFans=0&uid=2702608131&verifier=f3af5509&dpc=1"></iframe>
    </div>

    <div class="sidenav">
        <h2>Blog</h2>
        <ul class="artical-list">
        
            <li><a href="/posts/blog/17/10/15/dynamic-change-logger-level.html">动态变更log4j日志级别</a></li>
        
            <li><a href="/posts/blog/17/10/15/daily-shit.html">20171015一周坑</a></li>
        
            <li><a href="/posts/blog/17/04/22/spring-session-with-sharded-session.html">spring-session支持分片redis</a></li>
        
            <li><a href="/posts/blog/17/02/12/spring-session.html">spring session源码解析</a></li>
        
            <li><a href="/posts/blog/16/05/21/linux-common-command.html">工作中常用的linux命令</a></li>
        
            <li><a href="/posts/blog/16/05/19/hardware-interrupt-balance.html">硬件中断均衡</a></li>
        
            <li><a href="/posts/blog/16/04/17/a-oom-problem.html">一次oom的排查过程</a></li>
        
            <li><a href="/posts/blog/15/11/14/monitor-principle.html">监控模式</a></li>
        
            <li><a href="/posts/blog/15/11/14/jetty-deadlock.html">jetty6 deadlock</a></li>
        
            <li><a href="/posts/blog/15/08/21/linux-of-blockdump.html">linux系统之block_dump</a></li>
        
            <li><a href="/posts/blog/15/08/20/linux-of-pdflush.html">linux系统之pdflush</a></li>
        
            <li><a href="/posts/blog/15/08/11/UnknowHostException.html">UnknowHostException</a></li>
        
            <li><a href="/posts/blog/15/08/02/haproxy-install.html">haproxy部署</a></li>
        
            <li><a href="/posts/blog/15/07/25/maven-introduce.html">maven介绍</a></li>
        
            <li><a href="/posts/blog/15/06/21/etcd-vs-consul.html">ETCD vs. Consul</a></li>
        
            <li><a href="/posts/blog/15/06/21/distributed-id-generator.html">分布式ID生成器</a></li>
        
            <li><a href="/posts/blog/15/06/17/what-is-good-code.html">什么样的代码才是好的代码</a></li>
        
            <li><a href="/posts/blog/15/06/17/raft-introduce.html">Raft</a></li>
        
        </ul>
<!--
        <h2>Opinion</h2>
        <ul class="artical-list">
        
        </ul>

        <h2>Project</h2>
        <ul class="artical-list">
        
        </ul>-->
     </div>
</div>
<script src="/js/jquery-1.7.1.min.js"" type="text/javascript"></script>
<script src="/js/post.js" type="text/javascript"></script>

      

</body>
</html>
